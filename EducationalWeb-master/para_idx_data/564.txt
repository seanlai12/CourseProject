Constraints, such as on similarity measurements, can lead to heavy costs in clustering. Consider the following clustering with obstacles problem: To cluster people as moving objects in a plaza, Euclidean distance is used to measure the walking distance between two points. However, a constraint on similarity measurement is that the trajectory implementing the shortest distance cannot cross a wall (Section 11.4.1). Because obstacles may occur between objects, the distance between two objects may have to be derived by geometric computations (e.g., involving triangulation). The computational cost is high if a large number of objects and obstacles are involved. The clustering with obstacles problem can be represented using a graphical notation. First, a point, p, is visible from another point, q, in the region R if the straight line joining p and q does not intersect any obstacles. A visibility graph is the graph, VG = (V , E), such that each vertex of the obstacles has a corresponding node in V and two nodes, v 1 and v 2 , in V are joined by an edge in E if and only if the corresponding vertices they represent are visible to each other. Let VG = (V , E ) be a visibility graph created from VG by adding two additional points, p and q, in V . E contains an edge joining two points in V if the two points are mutually visible. The shortest path between two points, p and q, will be a subpath of VG , as shown in Figure 11.16(a). We see that it begins with an edge from p to either v 1 , v 2 , or v 3 , goes through a path in VG, and then ends with an edge from either v 4 or v 5 to q. To reduce the cost of distance computation between any two pairs of objects or points, several preprocessing and optimization techniques can be used. One method groups points that are close together into microclusters. This can be done by first triangulating the region R into triangles, and then grouping nearby points in the same triangle into microclusters, using a method similar to BIRCH or DBSCAN, as shown in Figure 11.16(b). By processing microclusters rather than individual points, the overall computation is reduced. After that, precomputation can be performed to build two kinds of join indices based on the computation of the shortest paths: (1) VV indices, for any pair of obstacle vertices, and (2) MV indices, for any pair of microcluster and obstacle vertex. Use of the indices helps further optimize the overall performance. Using such precomputation and optimization strategies, the distance between any two points (at the granularity level of a microcluster) can be computed efficiently. Thus, the clustering process can be performed in a manner similar to a typical efficient k-medoids algorithm, such as CLARANS, and achieve good clustering quality for large data sets. 