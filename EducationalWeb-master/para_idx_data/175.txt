Modify META's index::ir_eval class to add support for mean reciprocal rank (MRR) evaluation. In this chapter, we discuss one of the most important applications of text retrieval: web search engines. Although many information retrieval algorithms had been developed before the web was born, it created the best opportunity to apply those algorithms to a major application problem that everyone cares about. Naturally, there had to be some further extensions of the classical search algorithms to fully address new challenges encountered in web search. First, this is a scalability challenge. How can we handle the size of the web and ensure completeness of coverage of all its information (be it textual or not)? How can we serve many users quickly by answering all their queries? Before the web was born, the scale of search was relatively small, usually focused on libraries, so these questions were not serious. The second problem is that there is much low quality information known as spam. Search engine optimization is the attempt to heighten a particular page's rank by taking advantage of how pages are scored, e.g., adding many words that are not necessarily relevant to the actual content or creating many fake links to a particular page to make it seem more popular than it really is. Many different approaches have been designed to detect and prevent such spamming practices [Spirin and Han 2012]. The third challenge is the dynamic nature of the web. New pages are constantly created and updated very quickly. This makes it harder to keep the index fresh with the most recent content. These are just some of the challenges that we have to solve in order to build a high quality web search engine. Despite these challenges, there are also some interesting opportunities that we can leverage to improve search results. For example, we can imagine that using links between pages can improve scoring. The algorithms that we talked about such as the vector space model are generalthey can be applied to any search application. On the other hand, they also don't take advantage of special characteristics of pages or documents in specific applications such as web search. Due to these challenges and opportunities, there are new 192 Chapter 10 Web Search techniques that have been developed specifically for web search. One such technique is parallel indexing and searching. This addresses the issue of scalability; in particular, Google's MapReduce framework is very influential. There are also techniques that have been developed for addressing the spam problem. We'll have to prevent those spam pages from being ranked high. There are also techniques to achieve robust ranking in the light of search engine optimizers. We're going to use a wide variety of signals to rank pages so that it's not easy to spam the search engine with one particular trick. The third line of techniques is link analysis; these are techniques that can allow us to improve search results by leveraging extra information about the networked nature of the web. Of course, we will use multiple features for ranking-not just link analysis. We can also exploit all kinds of features like the layout of web pages or anchor text that describes a link to another page. The first component of a web search engine is the crawler. This is a program that downloads web page content that we wish to search. The second component is the indexer, which will take these downloaded pages and create an inverted index. The third component is retrieval, which answers a user's query by talking to the user's browser. The browser will show the search results and allow the user to interact with the web. These interactions with the user allow opportunities for feedback (discussed in Chapter 7) and evaluation (discussed in Chapter 9). In the next section, we will discuss crawling. We've already described all indexing steps except crawling in detail in Chapter 8. After our crawling discussion, we move onto the particular challenges of web indexing. Then, we discuss how we can take advantage of links between pages in link analysis. The last technique we discuss is learning to rank, which is a way to combine many different features for ranking. 