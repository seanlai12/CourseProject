Once an inverted index is built, scoring a query term-by-term can be done efficiently on an inverted index I dx using Algorithm 8.1 with query q. For each term, fetch the corresponding entries (frequency counts) in the inverted index. Create document score accumulators as needed (variables that hold the accumulated score for each document). Scan the inverted index entries for the current term and for each entry (corresponding to a document containing the term), update its score accumulator based on some term weighting method (the score_ term function). This could be (for example) Okapi BM25. As we finish processing all the query terms, the score accumulators should have the final scores for all the documents that contain at least one query term. Note that we don't need to create a score accumulator if the document doesn't match any query term. In reality, the fetch_docs function would return some object that contains information about the current term in the document, such as count, background probability, or any other necessary information that the score_term function would need to operate. Once we've iterated through all the query terms, the score accumulators have been finalized. We just need to sort these documents by their accumulated scores 