One disadvantage to term-at-a-time ranking is that the size of the score accumulators scores will be the size of the number of documents matching at least one term. While this is a huge improvement over all documents in the index, we can still make this data structure smaller. Instead of iterating through each document multiple times for each matched query term occurrence, we can instead score an entire document at once. Since most (if not all) searches are top-k searches, we can only keep the top k documents at any one time. This is only possible if we have the complete score for each document in our structure that holds scored documents. Otherwise, as with term-at-a-time scoring, a document may start out with a lower score than another, only to surpass it as more terms are scored. We can hold the k best completely scored documents with a priority queue. Using the inverted index, we can get a list of document IDs and postings data that need to be scored. As we score a complete document, it is added on the priority queue. We assign high priorities to documents with low scores; this is so that after adding the (k + 1) st document, we can (in O(log k) time) remove the lowest-score document and only hold onto the top k. Once we've iterated through all the document IDs, we can easily sort the k documents and return them. See Algorithm 8.2. We can use a similar priority queue approach while extracting the top k documents from the term-at-a-time score accumulators, but we would still need to store all the scores before finding the top k. 