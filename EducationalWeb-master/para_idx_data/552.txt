A large graph is often sparse, meaning each vertex on average connects to only a small number of other vertices. A similarity matrix from a large sparse graph can also be sparse. There are two kinds of methods for clustering graph data, which address these challenges. One uses clustering methods for high-dimensional data, while the other is designed specifically for clustering graphs. The first group of methods is based on generic clustering methods for highdimensional data. They extract a similarity matrix from a graph using a similarity measure such as those discussed in Section 11.3.2. A generic clustering method can then be applied on the similarity matrix to discover clusters. Clustering methods for high-dimensional data are typically employed. For example, in many scenarios, once a similarity matrix is obtained, spectral clustering methods (Section 11.2.4) can be applied. Spectral clustering can approximate optimal graph cut solutions. For additional information, please refer to the bibliographic notes (Section 11.7). The second group of methods is specific to graphs. They search the graph to find well-connected components as clusters. Let's look at a method called SCAN (Structural Clustering Algorithm for Networks) as an example. Given an undirected graph, G = (V , E), for a vertex, u ∈ V , the neighborhood of u is (u) = {v|(u, v) ∈ E} ∪ {u}. Using the idea of structural-context similarity, SCAN measures the similarity between two vertices, u, v ∈ V , by the normalized common neighborhood size, that is, (11.40) The larger the value computed, the more similar the two vertices. SCAN uses a similarity threshold ε to define the cluster membership. For a vertex, u ∈ V , the ε-neighborhood of u is defined as N ε (u) = {v ∈ (u)|σ (u, v) ≥ ε}. The ε-neighborhood of u contains all neighbors of u with a structural-context similarity to u that is at least ε. In SCAN, a core vertex is a vertex inside of a cluster. That is, u ∈ V is a core vertex if |N ε (u)| ≥ µ, where µ is a popularity threshold. SCAN grows clusters from core vertices. If a vertex v is in the ε-neighborhood of a core u, then v is assigned to the same cluster as u. This process of growing clusters continues until no cluster can be further grown. The process is similar to the density-based clustering method, DBSCAN (Chapter 10). Formally, a vertex v can be directly reached from a core u if v ∈ N ε (u). Transitively, a vertex v can be reached from a core u if there exist vertices w 1 , . . . , w n such that w 1 can be reached from u, w i can be reached from w i−1 for 1 < i ≤ n, and v can be reached from w n . Moreover, two vertices, u, v ∈ V , which may or may not be cores, are said to be connected if there exists a core w such that both u and v can be reached from w. All vertices in a cluster are connected. A cluster is a maximum set of vertices such that every pair in the set is connected. Some vertices may not belong to any cluster. Such a vertex u is a hub if the neighborhood (u) of u contains vertices from more than one cluster. If a vertex does not belong to any cluster, and is not a hub, it is an outlier. The SCAN algorithm is shown in Figure 11.15. The search framework closely resembles the cluster-finding process in DBSCAN. SCAN finds a cut of the graph, where each cluster is a set of vertices that are connected based on the transitive similarity in a structural context. An advantage of SCAN is that its time complexity is linear with respect to the number of edges. In very large and sparse graphs, the number of edges is in the same scale of the number of vertices. Therefore, SCAN is expected to have good scalability on clustering large graphs. Algorithm: SCAN for clusters on graph data. Input: a graph G = (V , E), a similarity threshold ε, and a population threshold µ Output: a set of clusters Method: set all vertices in V unlabeled for all unlabeled vertex u do if u is a core then generate a new cluster-id c insert all v ∈ N ε (u) into a queue Q while Q = do w ← the first vertex in Q R ← the set of vertices that can be directly reached from w for all s ∈ R do if s is not unlabeled or labeled as nonmember then assign the current cluster-id c to s endif if s is unlabeled then insert s into queue Q endif endfor remove w from Q end while else label u as nonmember endif endfor for all vertex u labeled nonmember do if ∃x, y ∈ (u) : x and y have different cluster-ids then label u as hub else label u as outlier endif endfor Figure 11.15 SCAN algorithm for cluster analysis on graph data. 