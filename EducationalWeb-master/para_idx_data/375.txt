First, we would need to define the data types that we may be interested in processing. Naturally, the most important data type is a TEXTOBJECT, which can be defined as a sequence of words in a vocabulary set V . Clearly, a word, a phrase, a sentence, a paragraph, and an article can all be regarded as specific instances of the type TEXTOBJECT. We can then also naturally define derived data types based on TEXTOBJECT, including, e.g., TEXTOBJECTSET, which naturally captures instances such as a collection of text articles, a set of sentences, which further covers a set of terms as a special case when a sentence is just a term. Another possibility is TEXTOBJECTSEQUENCE, where we care about order of the text objects; TEXTOBJECTSEQUENCE can capture interesting data structures such as a ranked list of articles or sentences. Again, a special case is a ranked list of terms. Based on these types, we may also further define a topic as a WEIGHTEDTEXT-OBJECTSET, where each text object is associated with a numerical weight. As a special case, we can have words as text objects, and thus have a word distribution represented as a WEIGHTEDTEXTOBJECTSET. WEIGHTEDTEXTOBJECTSEQUENCE can cover a ranked list of search results with scores. Second, we need to define operators on top of various data types. Here we can potentially have a very large number of operators, depending on specific text analysis algorithms. Here we briefly discuss a few most commonly used algorithms that we covered in the previous chapters of the book, and show that even with a few operators, we can already potentially combine them in many different ways to flexibly support very different workflows required in a particular application context. For example, in Figure 20.3, we show the following operators. Since our goal is mainly to present some speculative ideas, we present these operators in a mostly informal and non-rigorous way. Select. TEXTOBJECTSET → TEXTOBJECTSET. The Select operator maps a set of text objects into a subset of text objects. Querying, browsing, and recommendation can all be regarded as an instance of Select. We can additionally further apply a Ranking operator to each selection. Split. TEXTOBJECTSET → TEXTOBJECTSET, . . . , TEXTOBJECTSET. The Split operator maps a set of text objects into multiple subsets of text objects. Text categorization and text clustering are all instances of Split. Union and Intersection. these are standard set operators that can be applied to any sets. Ranking. (WEIGHTED) TEXTOBJECTSET → TEXTOBJECTSEQUENCE. The Ranking operator takes as input a weighted set of text objects that specifies the perspective of ranking and a set of text objects, and it produces a sequence of text objects (sorted in order) as output. As a special case, the WEIGHTED TEXTOBJECTSET can be a word distribution representing a query language model. 